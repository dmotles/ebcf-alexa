#!/usr/bin/env python3
"""
This script deploys or updates new versions of the deploy/management infrastructure.
"""
import os
import boto3
import sys
import yaml
import logging
import threading
import time
import pprint
from functools import wraps
from typing import Callable, Any, Optional
from botocore.exceptions import ClientError
import pdb


# hard-coded stack params
REGION = 'us-east-1'
TEST_STACK = 'test-ebcf-alexa'
PROD_STACK = 'ebcf-alexa'
ROOT = os.path.dirname(os.path.realpath(__file__))
TEMPLATE_PATH = os.path.join(ROOT, 'cloudformation', 'ebcf-alexa-lambda.template.yml')

# libs
cfn = boto3.resource('cloudformation', region_name='us-east-1')
cfn_client = cfn.meta.client
log = logging.getLogger(__name__)


##
#
# YAML
#
##
class CfnYamlLoader(yaml.Loader):
    def construct_cfn_func_list(self, node):
        fn = 'Fn::{}'.format(node.tag[1:])
        return {fn: [self.construct_yaml_str(n) for n in node.value]}

    def construct_cfn_func_scalar(self, node):
        fn = 'Fn::{}'.format(node.tag[1:])
        return {fn: node.value}

    def construct_cfn_func_join(self, node):
        delimeter, values = node.value
        return {'Fn::Join': [self.construct_yaml_str(delimeter), map(self.construct_yaml_str, values)]}


CfnYamlLoader.add_constructor('!GetAtt', CfnYamlLoader.construct_cfn_func_list)
CfnYamlLoader.add_constructor('!Ref', CfnYamlLoader.construct_cfn_func_scalar)
CfnYamlLoader.add_constructor('!Join', CfnYamlLoader.construct_cfn_func_join)


def is_stack_does_not_exist_error(stack_name: str, err: ClientError) -> bool:
    response = err.response['Error']
    not_exist_msg = '{} does not exist'.format(stack_name)
    return response['Type'] == 'Sender' and \
            response['Code'] == 'ValidationError' and \
            not_exist_msg in response['Message']


class StackCreateUpdateException(Exception):
    def __init__(self, what_happened: str, why: str):
        super().__init__()
        self.what_happened = what_happened.replace('_IN_PROGRESS', '')
        self.why = why

    def __str__(self):
        return '{0.__class__.__name__}: {0.what_happened} because {0.why}'.format(self)


class StackWatcher(threading.Thread):
    UPDATE_SUCCESS_STATES = frozenset((
        'UPDATE_COMPLETE',
    ))

    CREATE_SUCCESS_STATES = frozenset((
        'CREATE_COMPLETE',
    ))

    DELETE_SUCCESS_STATES = frozenset((
        'DELETE_COMPLETE',
    ))

    UPDATE_FAILURE_STEADY_STATES = frozenset((
        'UPDATE_ROLLBACK_FAILED',
        'UPDATE_ROLLBACK_COMPLETE',
    ))

    UPDATE_FAILURE_STATES = UPDATE_FAILURE_STEADY_STATES.union({
        'UPDATE_ROLLBACK_IN_PROGRESS',
        'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS',
    })

    CREATE_FAILURE_STEADY_STATES = frozenset((
        'CREATE_FAILED',
        'ROLLBACK_COMPLETE',
        'ROLLBACK_FAILED',
    ))

    CREATE_FAILURE_STATES = CREATE_FAILURE_STEADY_STATES.union({
        'ROLLBACK_IN_PROGRESS'
    })

    DELETE_FAILURE_STATES = frozenset((
        'DELETE_FAILED',
    ))

    STEADY_STATE = UPDATE_SUCCESS_STATES | CREATE_SUCCESS_STATES | DELETE_SUCCESS_STATES | \
        UPDATE_FAILURE_STEADY_STATES | CREATE_FAILURE_STEADY_STATES | DELETE_FAILURE_STATES

    def __init__(self, stack,
                 deleting=False,
                 goal_states=CREATE_SUCCESS_STATES.union(UPDATE_SUCCESS_STATES),
                 fail_states=CREATE_FAILURE_STATES.union(UPDATE_FAILURE_STATES)):
        super(StackWatcher, self).__init__()
        self.__lock = threading.Lock()
        self.__done = threading.Event()
        self.__exc = None   # < lock
        self.__result = None  # < lock
        self.goal_states = goal_states
        self.fail_states = fail_states
        self.stack = stack
        self.deleting = deleting
        stack.load()  # load stack once to ensure its legit before thread starts

    def __set_exception(self, exc: Exception):
        with self.__lock:
            if self.__exc is None:
                self.__exc = exc
                self.__done.set()

    def __set_result(self, result):
        with self.__lock:
            if self.__result is None:
                self.__result = result
                self.__done.set()

    def run(self):
        try:
            while 'IN_PROGRESS' in self.stack.stack_status:
                log.info('Stack Name: %s Status: %s Reason: %s',
                         self.stack.name,
                         self.stack.stack_status,
                         self.stack.stack_status_reason)

                # possibly notify waiter early of a problem - so the waiter can decide to go do something
                # else instead of waiting on CFN
                if self.stack.stack_status in self.fail_states:
                    self.__set_exception(
                        StackCreateUpdateException(self.stack.stack_status, self.stack.stack_status_reason))
                    return
                time.sleep(5)
                self.stack.load() # get status

            if self.stack.stack_status in self.fail_states:
                self.__set_exception(
                    StackCreateUpdateException(self.stack.stack_status, self.stack.stack_status_reason))
            elif self.stack.stack_status in self.goal_states:
                self.__set_result((self.stack.stack_status, self.stack.stack_status_reason))
            else:
                self.__set_exception(
                    ValueError('Unexpected state/reason: {}/{}'.format(
                        self.stack.stack_status, self.stack.stack_status_reason)))
        except ClientError as client_err:
            if not is_stack_does_not_exist_error(self.stack.name, client_err) or not self.deleting:
                self.__set_exception(client_err)
        except Exception as e:
            self.__set_exception(e)
        finally:
            self.__done.set()

    def wait(self, timeout=7200):
        if not self.__done.wait(timeout):
            raise Exception('Timed out waiting for done')
        with self.__lock:
            if self.__exc is not None:
                raise self.__exc
            return self.__result


class Template(object):
    def __init__(self, template_content: bytes):
        self.template_content = template_content.decode('utf-8')
        res = cfn_client.validate_template(TemplateBody=self.template_content)
        log.debug('validate_template: %r', res)
        self.parameters = {
            p['ParameterKey']: p
            for p in res['Parameters']
        }
        self.description = res.get('Description')
        self.capabilities = res['Capabilities']

    def __repr__(self):
        return 'Template({!r})'.format(self.template_content)

    def __str__(self):
        return 'Template(parameters={0.parameters!r}, '\
                'description={0.description!r}, '\
                'capabilities={0.capabilities!r})'.format(self)

    def create_params(self, stack_name: str, **defaults):
        spaces = ''
        if len(stack_name) < 25:
            spaces = ' ' * (25 - len(stack_name))
        print('*********************************************************')
        print('* NEW STACK {} is being created.{} *'.format(stack_name, spaces))
        print('* Please validate/enter values for the following        *')
        print('* parameters:                                           *')
        print('*********************************************************')
        params = []
        for param_name, param in self.parameters.items():
            default = param.get('DefaultValue')
            default = defaults.get(param_name, default)
            value = prompt_new_value(param_name, default)
            if value is None:
                continue
            params.append({
                'ParameterKey': param_name,
                'ParameterValue': value
            })
        return params

    def create_stack(self, stack_name: str, **defaults):
        stack = cfn.create_stack(
            StackName=stack_name,
            TemplateBody=self.template_content,
            Parameters=self.create_params(stack_name, **defaults),
            Capabilities=self.capabilities
        )
        watcher = StackWatcher(stack)
        try:
            watcher.start()
            watcher.wait()
            return stack
        except StackCreateUpdateException:
            for event in stack.events.all():
                if event.resource_status in StackWatcher.CREATE_FAILURE_STATES:
                    log.error('%s [%s] of type %s %s because %s',
                              event.logical_resource_id,
                              event.physical_resource_id,
                              event.resource_type,
                              event.resource_status,
                              event.resource_status_reason)
                    log.debug('%s Resource blob: %s', event.logical_resource_id, event.resource_properties)
            raise

        finally:
            watcher.join()


def prompt_new_value(param_name: str, default: Optional[str]) -> Optional[str]:
    prompt = '{} [default: {}] : '.format(param_name, default) \
        if default is not None else '{} : '.format(param_name)

    while True:
        val = input(prompt).strip()
        if val:
            return val
        else:
            if default is not None:
                return
            print('{} does not have a default value and requires a value.'.format(param_name),
                  file=sys.stderr)


def load_template(template_name: str) -> Template:
    with open(template_name, 'rb') as f:
        return Template(f.read())


def get_stack(stack_name: str):
    try:
        for stack in cfn.stacks.filter(StackName=stack_name):
            if stack.name == stack_name:
                watcher = StackWatcher(stack,
                                       goal_states=StackWatcher.STEADY_STATE,
                                       fail_states=frozenset())
                watcher.start()
                watcher.wait()
                return stack
    except ClientError as clienterr:
        if is_stack_does_not_exist_error(stack_name, clienterr):
            return None
        raise


def delete_stack(stack) -> StackWatcher:
    log.info('Attempting to delete stack %s in status: %s', stack.name, stack.stack_status)
    stack.delete()
    s = StackWatcher(stack,
                     goal_states=StackWatcher.DELETE_SUCCESS_STATES,
                     fail_states=StackWatcher.DELETE_FAILURE_STATES,
                     deleting=True)
    s.start()
    return s


def create_or_update_stack(stack_name: str, template: Template, **param_defaults):
    stack = get_stack(stack_name)
    if stack is None or stack.stack_status == 'ROLLBACK_COMPLETE':
        if stack:
            s = delete_stack(stack)
            s.wait()
            s.join()
        template.create_stack(stack_name, **param_defaults)
    else:
        log.info('need to update instead of create.. status: %s', stack.stack_status)


def setup_logging():
    handler = logging.StreamHandler()
    handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(name)-32s %(levelname)-8s: %(message)s')
    handler.setFormatter(formatter)
    for logger in (log, logging.getLogger('boto3')):
        logger.setLevel(logging.DEBUG)
        logger.addHandler(handler)


def main() -> int:
    setup_logging()
    template = load_template(TEMPLATE_PATH)
    create_or_update_stack(TEST_STACK, template)
    # 3. merge old stack params with new stack params.
    # 3a. ask for missing values?
    # 4. do a stack update
    # 5. wait for it to complete or fail
    # 6. report back
    return 0


if __name__ == '__main__':
    sys.exit(main())
